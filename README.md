# C#で学ぶデザインパターン

## デザインパターンを学ぶ意味
神クラスを作って今作りたい動きを作ることはできるとしよう。  
しかし、実務で使うソースコードはただ動けばいいというわけではない。  
コードの変更は容易にできるか？コードの意図を人に簡潔に説明できるか？問題の修正に精神的な負荷は少ないか？  
これらの問題をクリアするための武器の一つとして、デザインパターンがある。  
今までも何度か学ぶ機会はあったが、大きなシステムの開発・保守の経験が浅かった自分にとっては無用の長物であった。  
「いつか役に立てばいい」ではない。  
実際に現在使っている業務用のソースコードは中途半端な改変を繰り返し、見るに堪えない姿になっている。  
このような現状を打破するべく、今までの自分への自戒の念も込めつつ、デザインパターンを学ぶ備忘録をここに記す。  

## 目次
- [C#で学ぶデザインパターン](#cで学ぶデザインパターン)
	- [デザインパターンを学ぶ意味](#デザインパターンを学ぶ意味)
	- [目次](#目次)
	- [Iteratorパターン](#iteratorパターン)
		- [登場する役](#登場する役)
	- [Adapterパターン](#adapterパターン)
		- [登場する役](#登場する役-1)
	- [Templateパターン](#templateパターン)
		- [登場する役](#登場する役-2)
	- [FactoryMethodパターン](#factorymethodパターン)
		- [登場する役](#登場する役-3)
	- [Singletonパターン](#singletonパターン)
		- [登場する役](#登場する役-4)
	- [Prototypeパターン](#prototypeパターン)
		- [登場する役](#登場する役-5)
	- [コーディング規則について](#コーディング規則について)

## Iteratorパターン
- 「一つずつ順番にアクセスする」を抽象化した概念。
- データの持ち方や処理の仕方に依存せず、「順番にアクセスする」という部分のみを実装する。
- ConcreteIteratorがConcreteAggregateの実装に依存するのは仕方ない。
- 暗黙的に依存するくらいなら依存関係作っちゃった方が良い。
### 登場する役
- Iterator（interface）  
  - 順次アクセスするためのインターフェース。
  - next()とhasNext()がある。
- Aggregate（interface）  
  - 順次アクセス可能な集合体であることを表すインターフェース。
  - イテレータを持っている。
- ConcreteElement（class）  
  - 集合の元のクラス。
  - intとかでもOK。
- ConcreteAgregator（class）  
  - 集合の実態を持ったクラス。
  - 集合はListや配列に限らず、「次」が定義されてればなんでもOK。
- ConcreteIterator（class）  
  - Iteratorを実装するクラス。
  - 集合クラスを知っている必要がある。

## Adapterパターン
- すでに提供されているものを使う際に良い感じにつなぎ合わせたり、別の機能として同じ処理をしたいときに良い感じに使ったりできるパターン。
- 直でもともとあるクラスの関数を使うのに比べて、名前を自由に付け替えれるのが強み。
- それによって同じ処理を「別機能として」使うことが可能。
- 名前を付け替えるパターンといってもよさそう。
再利用性がめちゃ上がる。
- クラスを継承するパターンだと結局ClientがAdapterを知ってないといけないから微妙な気もするが、踏み込むのがAdapterまででAdapteeと直接やり取りしていないのが大切な気もする。
### 登場する役
- Target（class or interface）
  - 今必要な処理があるクラスやインターフェース。
  - これがクラスの場合とインターフェースの場合で敬称を使うか委譲を使うかが分かれる。
- Client（function）
  - Targetを使って何かしたい人。
  - Mainであることが多そう？
- Adaptee（class）
  - Targetの処理として実装したい処理をすでに持っているクラス
- Adapter（class）
  - Targetの必要な機能をAdapteeの機能を使って再現するクラス。
  - 継承パターンか委譲パターンかで若干変わる

## Templateパターン
- 関数の具体的な実装をサブクラスに任せるパターン。  
- virtualを使うというだけでなく、処理の流れをまとめた関数は作っておくというのが特徴。
### 登場する役
- AbstractClass
  - 処理の流れだけを定義している抽象クラス。
  - 処理の流れのみをまとめた関数ははTemplate関数と呼ばれる。
- ConcreteClass
  - 具体的な処理の中身を実装しているクラス。

## FactoryMethodパターン
- インスタンスの生成を担当するクラスを持っておくパターン。
- 利点は生成時の処理が重い（またはそれがメイン）の場合に、インスタンス生成を請け負うクラスを持って置けること。
- 例えば敵キャラの生成で、画面の敵をランダムに出現させたいとする。
- CreatorのCreateメソッドをTemplateメソッドと見立てればTemplatePatternをクラスの生成に適用したものと考えることもできる。
### 登場する役
- Creator（class）
  - productを作るための抽象クラス。
  - ここにproduct作成時のTemplateメソッドを書いておく
- ConcreteCreator（class）
  - 実際にproductを作成する。
  - どのproductでも共通して行いたい処理はCreatorのTemplateメソッドに書いてあるため、個別のproductごとのコンストラクタ的な奴を作ればOK。
- Product（class）
  - 複数ある可能性のあるプロダクト。
  - 例ではUse()が定義されているが、あってもなくてもOK。
- ConcreteProduct（class）
  - 具体的なProductを実装するクラス。
  - コンストラクタは内部的なことだけでOK。
  - 例えば外部の配列に自分を登録したりとかはCreatorがやるからいい。

## Singletonパターン
- インスタンスを1つしか持たないことを保証するパターン。
- Unityにおいてたまーに使いたくなる。
  - BGMを鳴らすスクリプトをシーンごとに置きたくないとか。
### 登場する役
- Singleton（class）
  - 常に一つだけ存在したいようなクラス。

## Prototypeパターン
- すでにあるインスタンスから新しいインスタンスを作成するパターン。
- コピーコンストラクタがあればよさそうな気もするが、interfaceとしてPrototypeインターフェースを作っておくことが大事なんだと思う。
- 明示的にパターンを用いるという意味で。
- Prototype内にCloneのほかにも必要最小限の関数を入れて、「Product」、みたいなインターフェースにしてもいいかも？
- 全体に言えることだが、具体的なクラス名が出てこない抽象的なメソッドやクラスの作成は、再利用性という観点で作りまくるとよい。
- 現在作っている処理に必要な最小限のクラスは何かということを意識するとよい。
### 登場する役
- Prototype（interface）
  - ICloneableという名前でもいいかもしれない。
  - デフォルトであるけど非推奨っぽい。
- ConcretePrototype（class）
  - Prototypeの実装を行うクラス。
- Client（class）
  - Prototypeを使うクラス。
  - Prototypeのテスト以外はPrototypeを直で使うことは少ないと思う。
  - ICopyableのみが必要な場面は少ないだろう。

## コーディング規則について
- 基本的には以下の[C#での命名規則](https://marunaka-blog.com/csharp-naming-conventions/5680/#google_vignette)を参照
- 省略は基本しない。スマートさより理解しやすさ。
- クラス名：パスカル
- インターフェース名：パスカルケース　＆　先頭にI（大文字i）
- メンバ変数
  - 基本的に名詞を使う
  - private : キャメル
  - それ以外 : パスカル
- フィールド名
  - private : キャメル
  - それ以外 : パスカル
- メソッド名：パスカル
- その他
  - 変数の命名は「[codic](https://codic.jp/engine)」も参考に